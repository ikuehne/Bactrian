; 
; Copyright 2015 Ian Kuehne.
;
; Email: ikuehne@caltech.edu
;
; This file is part of Bactrian.
;
; Bactrian is free software: you can redistribute it and/or modify it under the
; terms of the GNU General Public License as published by the Free Software
; Foundation, either version 3 of the License, or (at your option) any later
; version.
;
; Bactrian is distributed in the hope that it will be useful, but WITHOUT ANY
; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
; A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License along with
; Bactrian.  If not, see <http://www.gnu.org/licenses/>.

;;
;; The part of the Bactrian runtime written in Bactrian.
;;

;; Control structures.

(define let
  (macro exprs
         ((lambda (bindings body)
                  ((lambda (name binding)
                     `((lambda (,name) ,body) ,binding))
                         (fst bindings) (snd bindings)))
                      (car exprs) (cdr exprs))))

(define testmacro
  (macro x
         (let (asfunction (cons 'lambda x))
         (let (asmacro (cons 'macro x))
           (lambda (x) (print (asfunction x)) (asmacro x))))))


; Composition operator.
(define (. f g)
  (lambda (x)
    (f (g x))))

; Sequencing operations. Evaluate all arguments, returning only the last one.
(define seq 
  (lambda args 
    (fold (lambda (x y) y)
          ()
          args)))

;; List functions.

; Return a well-formed list of all arguments.
(define list (lambda args args))

; Check if a value is nil.
(define (nil? x) (= nil x))

; Left fold over lists.
(define (fold f init lst)
  (if (nil? lst)
    init
    (fold f (f init (car lst)) (cdr lst))))

; Reverse a list.
(define reverse
  (seq
    (define (aux l accum)
        (if (nil? l)
          accum
          (aux (cdr l) (cons (car l) accum))))
    (lambda (l) (aux l nil))))

; Right fold over lists.
(define (foldr f init lst)
  (fold f init (reverse lst)))

; Map a function over a list.
(define (map f lst)
  (foldr
    (lambda (b_list a)
      (cons (f a) b_list))
    '()
    lst))

; Accessing elements of a list.
(define fst car)
(define snd (. car cdr))
(define thrd (. car (. cdr cdr)))

; Variadic '+' and '*' functions.  The faster binary operations are available as
; '+.' and '-.'.
(define + (lambda args (fold +. 0 args)))
(define * (lambda args (fold *. 1 args)))


;(define testlet
;  (testmacro exprs
;         ((lambda (bindings body)
;                  ((lambda (name binding)
;                     (list (cons 'lambda (cons (list name) body)) binding))
;                         (car bindings) (car (cdr bindings))))
;                      (car exprs) (cdr exprs))))

